
# =========================================================================== #
# SHARED
# =========================================================================== #
# source lib/sh/prepress.functions # MOVE TO MAIN .SH

# GLOBAL REUSE
# --------------------------------------------------------------------------- #
# ONLY SET ONCE (FOR NOW. TO BE CLEANED)
  if [ `echo $EMPTYLINE | wc -c` -lt 10 ]; then
  MKLONG=`printf "X%.0s" {1..100}`
  EMPTYLINE=`echo $RANDOM | md5sum | cut -d " " -f 1`$MKLONG
  APND=A${RANDOM}ND
  ESC=ES${RANDOM}C
  fi

  QRHREFIMG="lib/img/qrwww.svg"

# --------------------------------------------------------------------------- #
# WRITE TO DUMP
# --------------------------------------------------------------------------- #
  function write2src() { echo "$*" >> $SRCDUMP ; }
# --------------------------------------------------------------------------- #

# --------------------------------------------------------------------------- #
# MAKE LOCAL IF NECESSARY
# --------------------------------------------------------------------------- #
  WGETLOG=${TMPID}.wget

  function getFile() {

  SOURCE=$1
  TARGET=$2

  if [ `echo $TARGET | wc -c` -lt 2 ]; then SUCCESS="NO"
       #echo "No target provided! Skipping." 
  else
  if [ -f $TARGET ]; then SUCCESS="YES"
       #echo "$TARGET already here"
  else
        IFHTTP=`echo $SOURCE | grep "http.\?://" | wc -l`
        if [ $IFHTTP -ge 1 ]; then
             URL=$SOURCE;
             RESPONSE=`curl -s -o /dev/null -IL -w "%{http_code}" $URL`
             if [ $RESPONSE == '200' ]; then
                  wget --no-check-certificate -d \
                       -O $TARGET $URL >> $WGETLOG 2>&1 # > /dev/null 2>&1
                  SUCCESS="YES"
             else
                  echo "$URL does not exist! Skipping."
                  SUCCESS="NO"
             fi
        else
             if [ `ls $SOURCE 2>/dev/null | wc -l` -le 0 ];then
             echo "No valid input provided!"
             SUCCESS="NO"
             else
             SUCCESS="YES"
             cp $SOURCE $TARGET
             fi
      fi
    fi
  fi

  }






# --------------------------------------------------------------------------- #
# GENERATE QR CODE FOR INCLUSION
# --------------------------------------------------------------------------- #

  function mkqr() { sleep 0; }

#  QRDEKOSRC=EDIT/151007_qrdeko-simple.svg
#   QRURLLOG=${TMPID}.qrurls
#
#  function mkqr() {
#
#  QRID=`echo $* | sed 's/#/\n#/g' | #
#        grep -v "^#" | sed 's/ //g'`
#  QRID=`echo $QRID | md5sum | base64 | cut -c 1-5`
#
#  QURL="http://lfkn.de/$QRID"
#
## CREATE QR LINK
## --------------------------------------------------------
#  QRHREF=`echo "<div class=\"qr\">
#          <a href=\"$QURL\">
#          <img src=\"$QRHREFIMG\" />
#          </a></div>"             | #
#          sed ':a;N;$!ba;s/\n/ /g'| #
#          tr -s ' '               | #
#          sed 's/>[ ]*</></g'`      #
#
#  }
## --------------------------------------------------------------------------- #
#
#function QR() {
#
#      O=`echo $* | cut -d " " -f 1`
#
#  if [ X"$O" == XON   ] ||
#     [ X"$O" == XOFF  ]
#   then
#        QRMODE=$O
#        echo "QRMODE: $QRMODE"
#   else
#    if [ X"$QRMODE" != XOFF  ]; then
#        mkqr $*
#        write2src "$QRHREF"
#
#    fi
#  fi
#
#  }
#
#
#
## =========================================================================== #




# =========================================================================== #
# MAIN MDSH CONVERT FUNCTION
# =========================================================================== #

  function mdsh2src() {

# --------------------------------------------------------------------------- #
# DEFINE FUNCTION SPECIFIC PLACEHOLDERS
# --------------------------------------------------------------------------- #
  TMPBREAK=NX${RANDOM}XL ; TMPID2=`echo $RANDOM$RANDOM | cut -c 1-4`
# --------------------------------------------------------------------------- #
# INCLUDE FUNCTIONS
# --------------------------------------------------------------------------- #
  source $FUNCTIONS


# --------------------------------------------------------------------------- #
# AND ACTION PLEASE! 
# --------------------------------------------------------------------------- #
  #echo "--------------------------------------------------------------------"

# --------------------------------------------------------------------------- #
# PREPARE INPUT PARAMETERS 
# --------------------------------------------------------------------------- #
# TODO: NOT X AS IDENTIFIER
#       ??? LINES NECESSARY HERE

  INPUT=`echo $* | cut -d " " -f 1`; echo "input is: "$INPUT
  LINES=`echo $* | sed "s/ /\n/g"             | # SPACES TO NEWLINES
        #sed "s/[^0-9\\-]//g"                 | # REMOVE ALL EXCEPT NUMS AND -      UNNECCESSARY?!
        #grep -v "^[ ]*$"                     | # REMOVE EMPTY                      UNNECCESSARY?!
         sed -e '/^[0-9]\+-*[0-9]*$/s/^/X/g'  | # MARK LINE OPTION 
         grep "^X" | sed 's/^X//' | tail -n 1`  # SELECT LINE OPTION
  if [ `echo $LINES | wc -c` -gt 1 ]; then      # IF LINE OPTION IS SET
        echo "lines: $LINES"
        LINES=`echo $LINES | sed 's/-/,/'`
        SELECTLINES="sed -n \"${LINES}p\" "
  else
        SELECTLINES="tee" 
  fi

# --------------------------------------------------------------------------- #
# MAKE LOCAL IF NECESSARY
# --------------------------------------------------------------------------- #
  MDSH=${TMPID}.${TMPID2}.mdsh
  getFile $INPUT $MDSH
  if [ X$SUCCESS == XYES ];then
       RUN="YES"
  else
       RUN="NO"    
  fi

# =========================================================================== #
# --------------------------------------------------------------------------- #
# TRANSFORM (IF POSSIBLE/NECESSARY)
# --------------------------------------------------------------------------- #
  if [ "Y$RUN" == "YYES" ] && 
     [ -f $MDSH ] &&
     [ `wc -l $MDSH | cut -d " " -f 1` -gt 0 ]; then
 
# --------------------------------------------------------------------------- #
# PRE-PROCESSING
# --------------------------------------------------------------------------- #

# MOVE (% TO NEW LINE = ALLOW INLINE COMMANDS
  sed -i '/^%/!s/(% /\n!!!% /g' $MDSH
  sed -i "/^!!!%/s/)/\n$APND/"  $MDSH
  sed -i 's/^!!!%/%/'           $MDSH

# --------------------------------------------------------------------------- #
# SAVE MDSH LINES TO PROTECT FROM PANDOC
# --------------------------------------------------------------------------- #
  BCKUPCOMM=${TMPID}.${TMPID2}.commented 
  if [ -f $BCKUPCOMM ]; then rm $BCKUPCOMM ; fi
  PROTECTED=${TMPID}.${TMPID2}.mdshprotected
  cp $MDSH $PROTECTED
  
  if [ `grep "^%" $PROTECTED | wc -l` -gt 0 ]; then
  for COMMENTNUM in `grep -n "^%" $PROTECTED | #
                     cut -d ":" -f 1`
   do
        LINENUM=$COMMENTNUM
        COMMENT=`sed "${LINENUM}q;d" $MDSH`
      COMMENTID=`echo $COMMENT | md5sum | cut -d " " -f 1`$MKLONG
       sed -i "${LINENUM}s/^.*$/$COMMENTID/g" $PROTECTED
       echo "${COMMENTID}:${COMMENT}" >> $BCKUPCOMM
  done
  fi


# --------------------------------------------------------------------------- #
# CONVERT MARKDOWN WITH PANDOC (CUSTOM FOOTNOTES/BIBREFS)
# --------------------------------------------------------------------------- #
  MDSHMOD=${TMPID}.${TMPID2}.mdshmod
  if [ -f $MDSHMOD ]; then rm $MDSHMOD ; fi

  # TEMPORARY PROTECTORS (FOO)
  # ---------------------------------
    BREAKFOO=BR${RANDOM}EAK
      FN1FOO=FN${RANDOM}1 ; FN2FOO=FN${RANDOM}2
    CICOMMON=CM$RANDOM
      CI1FOO=${CICOMMON}CI${RANDOM}1 ; CI2FOO=CI${RANDOM}2
      CP1FOO=${CICOMMON}CP${RANDOM}1 ; CP2FOO=CP${RANDOM}2
     CODEFOO=CO${RANDOM}DE

  # THE GREAT ESCAPE
  # ---------------------------------
    FNOESC=$ESC`echo $FOOTNOTEOPEN     | #
                sed 's/\\\/\\\\\\\/g'  | #
                sed 's/\//\\\\\//g'`
    CTOESC=$ESC`echo $CITEOPEN         | #
                sed 's/\\\/\\\\\\\/g'  | #
                sed 's/\//\\\\\//g'`
    CPOESC=$ESC`echo $CITEPOPEN        | #
                sed 's/\\\/\\\\\\\/g'  | #
                sed 's/\//\\\\\//g'`

  cat $PROTECTED                         | # USELESS USE OF CAT
  eval "$SELECTLINES"                    | # CUSTOM COMMAND TO SELEC TLINES
 #sed "s/^ *$/$BREAKFOO$EMPTYLINE$BREAKFOO/g" | # PROTECT EMPTY LINES (BREAK FOR HEADINGS)
  sed "s/^ *$/$EMPTYLINE/g" | # PROTECT EMPTY LINES (BREAK FOR HEADINGS)
  sed "s/^[ ]\{4\}/$CODEFOO/"            | # PROTECT CODEBLOCKS
  sed ":a;N;\$!ba;s/\n/$BREAKFOO/g"      | # REMOVE LINEBREAKS (TEMPORARY)
  sed "s/\[\^\]{/\n$FN1FOO/g"            | # PROTECT (FOONOTE OPEN)
  sed "/^$FN1FOO/s/}/\n$FN2FOO/"         | # PROTECT (FOOTNOTE CLOSE)
  sed "s/\($BREAKFOO\)*[ ]*\[@\[/\n$CP1FOO/g" | # ++ PROTECT (CITEP OPEN)
  sed "s/\($BREAKFOO\)*[ ]*\[@/\n$CI1FOO/g"  | # ++ PROTECT (CITE OPEN)
  sed "/^$CP1FOO/s/\]/$CP2FOO/"          | # PROTECT (CITEP OPTION OPEN)
  sed "/^$CICOMMON/s/\]/$CI2FOO/"        | # PROTECT (CITE CLOSE)
  sed "s/$BREAKFOO/\n/g"                 | # RESTORE LINEBREAKS
  sed "s/$CODEFOO/    /"                 | # RESTORE CODEFOO
  sed "s/$EMPTYLINE/\n/"                 | # RESTORE CODEFOO
 #tee -a beforepandoc.debug | #
  eval "$PANDOCACTION"                   | # MD TO TARGET MARKUP
 #tee -a afterpandoc.debug | #
 #sed "/^<[^>]*>[a-f0-9]\{32\}$MKLONG<[^>]*>/s/<[^>]*>//g" | # REMOVE TAGS IF LINE IS 'FUNCTION'
  sed "/^<[^>]*>\([a-f0-9]\{32\}${MKLONG}[ ]*\)*<[^>]*>$/s/<[^>]*>//g" | # REMOVE TAGS IF IS 'FUNCTIONS ONLY'
  sed "s/[ \t]*$FN1FOO/$APND$FNOESC/g"   | # SUBSTITUTE WITH TARGET MARKUP 
  sed "s/[ \t]*$FN2FOO/$FOOTNOTECLOSE/g" | # SUBSTITUTE WITH TARGET MARKUP 
  sed "s/[ \t]*$CI1FOO/$APND$CTOESC/g"   | # SUBSTITUTE WITH TARGET MARKUP 
  sed "s/[ \t]*$CI2FOO/$CITECLOSE/g"     | # SUBSTITUTE WITH TARGET MARKUP 
  sed "s/[ \t]*$CP1FOO/$APND$CPOESC/g"   | # SUBSTITUTE WITH TARGET MARKUP 
  sed "s/[ \t]*$CP2FOO/$CITEPCLOSE/g"    | # SUBSTITUTE WITH TARGET MARKUP 
  tee > $MDSHMOD                           # WRITE TO FILE


# --------------------------------------------------------------------------- #
# MAKE MD5 HASH TO PREVENT (REPETITION)/RECURSION -> SKIP IF NECESSARY
# --------------------------------------------------------------------------- #
  MD5THIS=`md5sum $MDSHMOD | cut -d " " -f 1`
  touch ${TMPID}.included
  TIMESINCLUDED=`grep $MD5THIS ${TMPID}.included | wc -l`
  echo $MD5THIS >> ${TMPID}.included
 #echo $TIMESINCLUDED ; echo $MD5THIS # DEBUG

  if [ $TIMESINCLUDED -ge 5 ]; then
       echo "Skipping! (caught in a loop)"
       SKIP="YES"
  else
       SKIP="NO"
  fi

  if [ X"$SKIP" != XYES ]; then
# --------------------------------------------------------------------------- #
# RESTORE MDSH LINES (TODO: BETTER VARIABLES) 
# --------------------------------------------------------------------------- #
  if [ -f $BCKUPCOMM ]; then
  sed -i 's/\\/\\\\/g' $BCKUPCOMM # PROTECT ESCAPES (aka. \v PROBLEM)

  for COMMENTID in `cat $BCKUPCOMM | cut -d ":" -f 1 | sort -u`
   do
      COMMENT=`grep $COMMENTID $BCKUPCOMM   | # FIND COMMENT
               head -n 1 | cut -d ":" -f 2- | # SELECT AND RM ID
               sed 's/\//\\\\\//g'          | # ESCAPE CONTROL CHARACTER
               sed 's/&/\\\\\&/g'`            # ESCAPE CONTROL CHARACTER
      sed -i "s/$COMMENTID/\n$COMMENT\n/g" $MDSHMOD
   done
  fi


# CLEAN UP (RM: 'REAL' EMPTY LINES, ORPHAN HTML TAGS)
# ----------------------------------------------
  cat $MDSHMOD                    | #
  grep -v "^[ ]*$"                | #
 #grep -v "^[ ]*<[/]*.\{1,10\}>$" | #
  tee > tmptmp.tmp                  # WRITE TO TEMPORARY FILE
  mv tmptmp.tmp $MDSHMOD            # MOVE IN RIGHT PLACE

 # BUG: EMPTY LINE WITHIN INLINE CODE
 # cp $MDSHMOD mdshmod.debug # DEBUG

# --------------------------------------------------------------------------- #
# ADD INFORMATION (TO BE PROCESSED) 
# --------------------------------------------------------------------------- #
# SRCNFO="% SRC: $*"
# sed -i "1i$SRCNFO"   $MDSHMOD
# echo   "$SRCNFO"  >> $MDSHMOD

# --------------------------------------------------------------------------- #
# PARSE COMMANDS 
# --------------------------------------------------------------------------- #

  for LINE in `cat "$MDSHMOD" | sed 's, ,DieW73NaS03J,g'`
   do 
       # --------------------------------------------------- # 
       # RESTORE SPACES
         LINE=`echo "$LINE" | sed 's,DieW73NaS03J, ,g'`
       # --------------------------------------------------- #  
 
       # CHECK IF LINE STARTS WITH %
         ISCOMMENT=`echo $LINE | grep "^%" | wc -l` 
       # --------------------------------------------------- # 
       # IF LINE STARTS WITH %
         if [ $ISCOMMENT -ge 1 ]; then
 
            CMD=`echo "$LINE" | \
                 cut -d "%" -f 2 | \
                 cut -d ":" -f 1 | \
                 sed 's/\[/ /g' | sed 's/\]/ /g' |\
                 sed 's, ,,g'`
            ARG=`echo "$LINE" | cut -d ":" -f 2-`
       # --------------------------------------------------- # 
       # CHECK IF MATCHES COMMAND
 
            CMDMATCH=`grep "^function ${CMD}()" $FUNCTIONS |\
                       wc -l`
       # --------------------------------------------------- # 
       # IF COMMAND EXISTS 
         if [ $CMDMATCH -ge 1 ]; then
            # EXECUTE COMMAND
              $CMD "$ARG"
         else
            # KEEP COMMENT
              echo "$COMSTART $LINE $COMCLOSE" >>  $SRCDUMP
         fi
       # --------------------------------------------------- # 
       # IF LINE DOES NOT START WITH %
         else
       # --------------------------------------------------- # 
       # APPEND TO SOURCE
         echo "$LINE"  >> $SRCDUMP
         fi
       # --------------------------------------------------- # 
  done

# POST-PROCESSING
# --------------------------------------------------------------------------- #

  sed -i "s/$EMPTYLINE//g"     $SRCDUMP  # RESTORE EMPTY LINES
  sed -i '/./,/^$/!d'          $SRCDUMP  # REMOVE CONSECUTIVE BLANK LINES
 #sed -i "/^%/s/\(%\)\(.*\)%$/$COMSTART \2 $COMCLOSE/" $SRCDUMP # ADJUST COMMENTS
  sed -i "/^%/s/\(%\)\(.*\)[%]*$/$COMSTART \2 $COMCLOSE/" $SRCDUMP

 #sed -i -e :a  \
 #    -i -e "\$!N;s/\n*[ \t]*$APND//;ta" \
 #    -i -e 'P;D'                    $SRCDUMP  # APPEND & RM APPEND IDS
  sed -i -e :a  \
      -i -e "\$!N;s/\(<[/]*.\{1,10\}>\)*\n\(<[/]*.\{1,10\}>\)*[ \t]*$APND//;ta" \
      -i -e 'P;D'                    $SRCDUMP  # APPEND & RM APPEND IDS
  sed -i "s/[ \t]*$APND//g"          $SRCDUMP  # RM REMAINING APPEND IDS +SPACE
  sed -i "s/[ \t]*$ESC//g"           $SRCDUMP  # RM ESC IDS +SPACE 


# CLEANUP (FILES)
# --------------------------------------------------------------------------- #
  if [ -f $BCKUPCOMM ]; then rm $BCKUPCOMM ;fi
  if [ -f $PROTECTED ]; then rm $PROTECTED ;fi

  # REMOVE ID AGAIN (REMBERED TO PREVENT RECURSION)
    sed -i "/$MD5THIS/d" ${TMPID}.included

  fi
  fi

  }

# --------------------------------------------------------------------------- #




function INCLUDE() {

# TODOTODO: check, check, debug
# mdsh2src $PARAMETERSWITHOUTFUNCTIONS # TODOTODO

  echo "INCLUDE STARTS ====================================================="

# EXTRACT OPTIONAL PARAMETERS
# ---------------------------------------------------------
  FUNCTIONSHERE=`echo $* | sed 's/ /\n/g' | #
                 grep "\.functions$" | tail -n 1`

  if [ `echo $FUNCTIONSHERE | wc -c` -gt 1 ];then
  PARAMETERSWITHOUTFUNCTIONS=`echo $*        | #
                              sed 's/ /\n/g' | #
                              grep -v "\.functions$"`                                    # TODO: BETTER

# ATTACH FUNCTIONS TO MAIN FUNCTIONS
# ---------------------------------------------------------
  if [ `ls $FUNCTIONSHERE 2>/dev/null | wc -l` -gt 0 ];then

   FID=`date +%s%N`
 # ATTACH AND MARK FUNCTIONS
   echo "#  -- ${FID} -- START" >> $FUNCTIONS
   cat  $FUNCTIONSHERE          >> $FUNCTIONS
   echo "#  -- ${FID} -- END"   >> $FUNCTIONS
   FUNCTIONSADDED="YES"
 # SAVE FUNCTION ID (AS VARIABLE MAY BE OVERWRITTEN)
   echo $FID >> ${TMPID}.fid
   fi
   else
   FUNCTIONSADDED="NO"
  fi

# MAKE QR REFERENCE
# --------------------------------------------------------
  mkqr $*
  QRIDINC="$QRID"
  write2src "HEREQR$QRIDINC"

# PROCESS INPUT !!!!!
# --------------------------------------------------------
  mdsh2src $*

# ADD REFERENCE IF NOT SKIPPED
# --------------------------------------------------------
  QRHREF=`echo "$QRHREF"      | #
          sed 's/\//\\\\\//g' | # ESCAPE 
          sed 's/"/\\"/g'`      # ESCAPE

  if [ X"$SKIP"   != "XYES" ] &&
     [ Y"$RUN"    == "YYES" ] &&
     [ X"$QRMODE" != "XOFF" ]; then
       sed -i "s,HEREQR$QRIDINC,$QRHREF," $SRCDUMP
  else
       sed -i "/^HEREQR${QRIDINC}$/d" $SRCDUMP
  fi

  sed -i "/^HEREQR.*$/d" $SRCDUMP # EMERGENCY REMOVE

# REMOVE ADDED FUNCTIONS
# --------------------------------------------------------
  if [ -f ${TMPID}.fid ]; then

# LOAD LATEST FUNCTION ID
  FID=`tail -n 1 ${TMPID}.fid`
# REMOVE FROM FUNCTIONS
  sed -i "/${FID} -- START$/,/${FID} -- END$/d" ${FUNCTIONS}
# REMOVE FROM SAVED FUNCTIONS
  sed -i "/$FID/d" ${TMPID}.fid
# RELOAD FUNCTIONS
  source $FUNCTIONS

  fi

  echo "INCLUDE ENDS  ======================================================"
}





